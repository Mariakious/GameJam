# Τι Είναι το Delta Time

Όταν χειριζόμαστε ταχύτητες σε παιχνίδια πρέπει να είμαστε πολύ
προσεκτικοί. Ο κωδικός που τρέχει σε κάθε frame μπορεί να εκτελείται
και 60 φορές το δευτερόλεπτο (ανάλογα με τα FPS, frames per second)!

Συνήθως μας αρέσει να εκφράζουμε τις ταχύτητες ως pixels ανά
δευτερόλεπτο. Έστω ότι έχουμε ένα παράθυρο μεγέθους `640x640` και
θέλουμε το αυτοκίνητο του παιχνιδιού να καλύπτει την μισή οθόνη σε ένα
δευτερόλεπτο. Δηλαδή `int car_velocity = 320` (pixels / second). Δεν
μπορούμε απλά να αυξήσουμε την θέση του αυτοκινήτου κατά 320 μέσα στο
game loop, γιατί αυτό τρέχει μια φορά για κάθε frame!

Πρέπει να υπολογίσουμε πρώτα τον πραγματικό χρόνο που πέρασε κατά την
διάρκεια υπολογισμού του προηγούμενου frame. Αυτό είναι που ονομάζουμε
**delta time**. Αυτή η τιμή δεν μπορεί να είναι σταθερά γιατί άλλες
φορές ο υπολογιστής καθυστερεί αρκετά να υπολογίσει ένα δύσκολο frame
ενώ άλλες φορές τελειώνει σε 5 μόλις μιλιδευτερόλεπτα. Θέλουμε οι
νέες θέσεις των αντικειμένων να αντανακλούν την διάρκεια της ώρας που
*πραγματικά* πέρασε.

Ο πολλαπλασιασμός `car_velocity * delta_time` έχει μονάδες `(pixels /
second) * second = pixels`, δηλαδή αυτό που περιμέναμε. Εδώ τίθεται
μια ερώτηση: Πότε πρέπει να πολλαπλασιάζω με delta time και πότε όχι;
Πολλαπλασιάζουμε με delta time τις ταχύτητες, τις επιταχύνσεις (μια
φορά, γιατί το αποτέλεσμα θα προστεθεί σε μεταβλητή ταχύτητας) και
οτιδήποτε άλλο γενικά έχει μονάδες `X / sec`. Μπορείς να το
συγκρίνεις με το διαφορικό `ds` αν αυτό σε βολεύει.

**Αν δεν** είχαμε delta time τότε το παιχνίδι θα έτρεχε πολύ πιο βίαια
σε έναν γρήγορο υπολογιστή, ενώ παράλληλα απελπιστικά αργά σε ένα
παλιό laptop. Το speedrunning leaderboard του παιχνιδιού σου θα είχε
μόνο Καταριανούς.

## Bonus (από Game Programming Patterns)

Έστω ότι ο Αντρέας έχει έναν φθηνό υπολογιστή και ο Βαρδής έναν
ακριβό. Έστω επίσης ότι και οι δυο τρέχουν το ίδιο παιχνίδι με το
αυτοκίνητο που δείξαμε πριν, μόνο που τώρα είναι multiplayer.
Θεωρητικά πρέπει η θέση του αυτοκινήτου να είναι πάντοτε κοινή και για
τους δύο.

Επειδή ο υπολογιστής του Βαρδή είναι δυνατότερος, θα μπορέσει να
ζωγραφίσει 60 frames στον ίδιο χρόνο που ο Αντρέας ζωγραφίζει 5 (όμως
ο Βαρδής θα έχει πολύ μικρότερα delta time, και άρα το παιχνίδι θα
τρέχει smoothly για εκείνον). Γιατί πρέπει να μας ενοχλεί αυτό; Αφού
τα delta time υποτίθεται ότι θα φτιάξουν τις διαφορές!

Η αλήθεια είναι ότι λόγω rounding errors σε πράξεις μεταξύ floats, τα
οποία θα είναι πολύ συχνότερα στον υπολογιστή του Βαρδή (μιας και
αυτός κάνει περισσότερες πράξεις!), οι νέες θέσεις του ίδιου αρχικά
αυτοκινήτου θα διαφοροποιούνται όλο και περισσότερο καθώς τρέχει ο
χρόνος, τα μικρά σφάλματα θα συσσωρευτούν! Παράλληλα, πολλά physics
engines λειτουργούν με σταθερά time steps, γιατί ειδάλλως προκαλούνται
παράλογες εκτοξεύσεις στις κινήσεις των αντικειμένων (το έχετε δει
σίγουρα στην πράξη).

Για τον λόγο αυτό, σε ειδικές (και σπάνιες για εμάς) περιπτώσεις όπου
πρέπει το παιχνίδι να είναι όσο το δυνατόν περισσότερο
ντετερμινιστικό, προτιμάμε να ενημερώνουμε τις θέσεις των αντικειμένων
πολλές φορές σε κάθε frame, χρησιμοποιώντας πολλαπλάσια μιας
στοιχειώδους ποσότητας `MS_PER_UPDATE`. Αυτή η τιμή δεν πρέπει να
είναι ούτε πολύ μικρή (γιατί ζορίζουμε τον υπολογιστή) αλλά ούτε και
πολύ μεγάλη (γιατί το παιχνίδι γίνεται διακριτό, choppy).

```cpp
double lag = 0.0;

while (is_game_running)
{
    delta_time = ...;
    lag += delta_time;

    while (lag >= MS_PER_UPDATE)
    {
        update();
        lag -= MS_PER_UPDATE;
    }
    // Το υπόλοιπο lag που απομένει και δεν ξεπερνά
    // την ποσότητα MS_PER_UPDATE κρατιέται για το επόμενο frame

    // Δεν υπάρχει λόγος να ζωγραφίσουμε σε κάθε step
    // Ούτως ή άλλως, μόνο η τελευταία ζωγραφιά θα επικρατήσει σε ένα frame
    render();
}
```

Το όμορφο είναι ότι αυτή η τεχνική υπό την ματιά κάποιου που δεν ξέρει
πως λειτουργεί το hardware μοιάζει τελείως παράλογη. Να όμως που έχει
μια λογική! Γενικά αυτή η μέθοδος δεν θα σας απασχολήσει πολύ, αλλά
καλό είναι να την αναγνωρίζεται όταν την βλέπετε σε κώδικα τρίτων (μου
έχει συμβεί!).
